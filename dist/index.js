const strUtils	= require('coredigix-string');const assert	= require('assert');var cloner = (function (O) {'use strict';  // (C) Andrea Giammarchi - Mit Style  var    // constants    VALUE   = 'value',    PROTO   = '__proto__', // to avoid jshint complains    // shortcuts    isArray = Array.isArray,    create  = O.create,    dP      = O.defineProperty,    dPs     = O.defineProperties,    gOPD    = O.getOwnPropertyDescriptor,    gOPN    = O.getOwnPropertyNames,    gOPS    = O.getOwnPropertySymbols ||              function (o) { return Array.prototype; },    gPO     = O.getPrototypeOf ||              function (o) { return o[PROTO]; },    hOP     = O.prototype.hasOwnProperty,    oKs     = (typeof Reflect !== typeof oK) &&              Reflect.ownKeys ||              function (o) { return gOPS(o).concat(gOPN(o)); },    set     = function (descriptors, key, descriptor) {      if (key in descriptors) dP(descriptors, key, {        configurable: true,        enumerable: true,        value: descriptor      });      else descriptors[key] = descriptor;    },    // used to avoid recursions in deep copy    index   = -1,    known   = null,    blown   = null,    clean   = function () { known = blown = null; },    // utilities    New = function (source, descriptors) {      var out = isArray(source) ? [] : create(gPO(source));      return descriptors ? Object.defineProperties(out, descriptors) : out;    },    // deep copy and merge    deepCopy = function deepCopy(source) {      var result = New(source);      known = [source];      blown = [result];      deepDefine(result, source);      clean();      return result;    },    deepMerge = function (target) {      known = [];      blown = [];      for (var i = 1; i < arguments.length; i++) {        known[i - 1] = arguments[i];        blown[i - 1] = target;      }      merge.apply(true, arguments);      clean();      return target;    },    // shallow copy and merge    shallowCopy = function shallowCopy(source) {      clean();      for (var        key,        descriptors = {},        keys = oKs(source),        i = keys.length; i--;        set(descriptors, key, gOPD(source, key))      ) key = keys[i];      return New(source, descriptors);    },    shallowMerge = function () {      clean();      return merge.apply(false, arguments);    },    // internal methods    isObject = function isObject(value) {      /*jshint eqnull: true */      return value != null && typeof value === 'object';    },    shouldCopy = function shouldCopy(value) {      /*jshint eqnull: true */      index = -1;      if (isObject(value)) {        if (known == null) return true;        index = known.indexOf(value);        if (index < 0) return 0 < known.push(value);      }      return false;    },    deepDefine = function deepDefine(target, source) {      for (var        key, descriptor,        descriptors = {},        keys = oKs(source),        i = keys.length; i--;      ) {        key = keys[i];        descriptor = gOPD(source, key);        if (VALUE in descriptor) deepValue(descriptor);        set(descriptors, key, descriptor);      }      dPs(target, descriptors);    },    deepValue = function deepValue(descriptor) {      var value = descriptor[VALUE];      if (shouldCopy(value)) {        descriptor[VALUE] = New(value);        deepDefine(descriptor[VALUE], value);        blown[known.indexOf(value)] = descriptor[VALUE];      } else if (-1 < index && index in blown) {        descriptor[VALUE] = blown[index];      }    },    merge = function merge(target) {      for (var        source,        keys, key,        value, tvalue,        descriptor,        deep = this.valueOf(),        descriptors = {},        i, a = 1;        a < arguments.length; a++      ) {        source = arguments[a];        keys = oKs(source);        for (i = 0; i < keys.length; i++) {          key = keys[i];          descriptor = gOPD(source, key);          if (hOP.call(target, key)) {            if (VALUE in descriptor) {              value = descriptor[VALUE];              if (shouldCopy(value)) {                descriptor = gOPD(target, key);                if (VALUE in descriptor) {                  tvalue = descriptor[VALUE];                  if (isObject(tvalue)) {                    merge.call(deep, tvalue, value);                  }                }              }            }          } else {            if (deep && VALUE in descriptor) {              deepValue(descriptor);            }          }          set(descriptors, key, descriptor);        }      }      return dPs(target, descriptors);    }  ;  return {    deep: {      copy: deepCopy,      merge: deepMerge    },    shallow: {      copy: shallowCopy,      merge: shallowMerge    }  };}(Object));/** * Go Through object * * $$.path( * 		input	: obj, // object to go through * 		path	: 'a.b.c' | ['a', 'b', 'c'], * 		childkey: 'childrenKey' | ['childrenK1', ...], * 		template: obj or array, // default to {} * 		upsert	: true | false, // create path if not exists, implicitly true if template is set * ); * * @return { *       get found	: true if the path exists *       get exists	: alias to .found *        *       get value	: objectValue,// first found value *       set value	: set value to first found object * * 		 get values	: list of found values, case of multiple possible values * 		 set values : set value to multiple possible values *          *       get isCreated	: true|false // if the object is created by this api *       create()	// create the path if not created * * 		// if path do not exists, get the subPath that exists *       currentPath 		: current path (=path if upsert or created) *       get currentValue	: max found object *       set currentValue * } * * path examples: * 		'a.b.c.d' * 		'a.0.4.78c.ll' * 		'key.ke\\.y2.key3'	// we can escape period with . * * 		['a', 'b', 'c', 'd'] * 		['a', 0, 4, '78c', 'll'] * 		['key', 'ke.y2', 'key3'] * * $$.hasPath(inputObj, path) */function objPath(options){	// control	assert(arguments.length === 1, 'Needs exactly one argument.');	assert(options.hasOwnProperty('input'), 'options.input required');	assert(options.hasOwnProperty('path'), 'options.path required');	// vars	var input	= options.input,		path	= options.path,		childkey= options.childkey || null,		template= options.template || null,		upsert	= options.upsert || template != null;	// chilkey and template		if(			childkey !== null			&& upsert === true			&& !(				options.template				&& options.template.hasOwnProperty(childkey)			)		)			throw new Error('When "childkey" and "template" or "upsert" are set, "childkey" is required inside "template"');	// path	if(typeof path === 'string')		path	= strUtils.split(path, '.');	else if(		Array.isArray(path)		&& path.every(ele => typeof ele === 'string' || typeof ele === 'number')	){}	else throw new Error('uncorrect path.');	var currentNode		= input,		parentNode		= null,		parentObj		= null,		attrKey,		tmpValue,		pos				= 0,		len				= path.length,		resolved;	// path	function seekPath(){		for(; pos < len; ++pos){			attrKey		= path[pos]; console.log('----- ', attrKey)			parentNode	= currentNode;			// get the parentObj			if(childkey === null)				parentObj	= parentNode;			else {				if(!parentNode.hasOwnProperty(childkey))					break;				parentObj	= parentNode[childkey];				if(!parentObj && upsert === true) // create child collection if not exists					parentObj	= parentNode[childkey] = (template === null? {} : objUtils.clone(template[childkey]));			}			console.log('--- current obj : ', parentObj)			// get the next child			if(Array.isArray(parentObj)){				if(isNaN(attrKey))					throw new Error('Illegal attribute "' + attrKey +'" for an array');				if(typeof attrKey === 'string')					attrKey	= parseInt(attrKey);				if(attrKey < 0){					attrKey	+= parentObj.length;					if(attrKey < 0) throw new Error('Array out of bound');				}				else if(attrKey > parentObj.length && upsert === false)					break;			}			// else if(parentObj.hasOwnProperty(attrKey) === false){			// 	break;			// }			// create child if not exists			if(parentObj[attrKey])				currentNode	= parentObj[attrKey]			else if(upsert === true)				currentNode	= parentObj[attrKey] = (template === null ? {} : objUtils.clone(template));			else break;		}		resolved	= pos >= path.length;	}	// get the maximum accessible path	seekPath();	// result	var result	= {		build	: function(){			upsert	= true;			seekPath();		},		get value(){ return resolved ? currentNode : undefined; },		set value(vl){			if(resolved) parentObj[attrKey]	= vl;			else throw new Error('Path not resolved');		},		get resolved(){ return resolved },		get exists(){ return resolved }	};	return result;}const objUtils	= {	path		: objPath,	clone		: function(obj){ return cloner.shallow.copy(obj); },	deepClone	: function(obj){ return cloner.deep.copy(obj); },	merge		: function(){ return cloner.shallow.merge.apply(cloner.shallow, arguments); },	deepMerge	: function(){ return cloner.deep.merge.apply(cloner.deep, arguments); }};module.exports	= objUtils;